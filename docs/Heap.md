# 「堆 Heap」

1. 堆是一种满足特定条件的完全二叉树，主要可以分为两种类型。

   - 「大顶堆（max heap）」：任意节点的值 >= 其子节点的值。
   - 「小顶堆（min heap）」：任意节点的值 <= 其子节点的值。

2. 堆作为完全二叉树的特例，具有以下特性：

   - 最底层节点靠左填充，其他层节点都被填满。
   - 我们将二叉树的根节点成为“堆顶”，将底层最靠右的节点成为“堆底”。
   - 对于大顶堆（小顶堆），堆顶元素（根节点）的值分别是最大（最小）的。

3. 堆的常用操作
   
    堆通常用于实现「优先队列 priority queue」，大顶堆相当于元素按照从大到小的顺序出队的优先队列。
    
    |    方法名    |    描述    |  时间复杂度   |
    |:---------:|:--------:|:--------:|
    |  push()   |   元素入堆   | O(log n) |
    |   pop()   |  堆顶元素出堆  | O(log n) |
    |  peek()   |  访问堆顶元素  |   O(1)   |
    |  size()   | 获取堆的元素数量 |   O(1)   |
    | isEmpty() | 判断堆是否为空  |   O(1)   |

4. 实际应用中，我们可以直接使用编程语言提供的堆类（或优先队列类）。

5. 建堆操作

   1. 借助入堆操作实现

      首先，创建一个空堆。然后遍历列表，依次对每个元素执行“入堆操作”，即将元素添加至堆的尾部，再对该元素执行“从底到顶”的堆化。

      每当一个元素入堆，堆的长度就加一。由于节点是从顶到底依次被添加进二叉树的，因此堆是“自上而下”构建的。 

      设元素数量为 n，每个元素的入堆操作使用 O(log n) 时间，因此该建堆方法的时间复杂度为 O(n log n)。
   
   2. 通过遍历堆化实现

      实际上，我们可以实现一种更为高效的建堆方法，共分为两步。 

      1. 将列表所有元素原封不动地添加到堆中，此时堆的性质尚未得到满足。
      2. 倒序遍历堆（层序遍历的倒序），依次对每个非叶节点执行“从顶至底堆化”。 
   
      每当堆化一个节点后，以该节点为根节点的子树就形成一个合法的子堆。而由于是倒序遍历，因此堆是“自下而上”构建的。 
   
      之所以选择倒序遍历，是因为这样能够保证当前节点之下的子树已经是合法的子堆，这样堆化当前节点才是有效的。 

      值得说明的是，由于叶节点没有子节点，因此它们天然就是合法的子堆，无须堆化。

   3. 第二种方法的建堆方法的时间复杂度
   
       假设给定一个节点数量为 $n$，高度为 $h$ 的“完美二叉树”。
   
       ![完美二叉树](https://www.hello-algo.com/chapter_heap/build_heap.assets/heapify_operations_count.png)
   
       则节点“从顶到底堆化”的最大迭代次数等于该节点到叶节点的距离，即改节点的高度。因此，我们可以对各层的“节点数量 * 节点高度”求和，得到所有节点的堆化迭代次数总和。
       $$
       T(h) = 2^0h + 2^1(h-1) + 2^2(h-2) + \cdots + 2^{(h-1)}*1
       $$
       借助初中的数列知识，对 $T(h)$ 乘以 2 后再进行错位相减得到：
       $$
       \begin{align}
       2T(h) - T(h) &= T(h) = -2^0h + 2^1 + 2^2 + \cdots + 2^{h-1} + 2^h \\
       & = 2 * \frac{1-2^h}{1 - 2} - h \\
       & = 2^{h+1} - h - 2 \\
       & = O(2^h)
       \end{align}
       $$
       由于完美二叉树中，节点数量为 $n = 2^{h+1}-1$，则可知
       $$
       \begin{align}
       O(2^h) = O(2^{\log_{2}(n+1) - 1}) = O(n)
       \end{align}
       $$
       以上推算表明，输入列表并建堆的时间复杂度为 O(n)，非常高效。
