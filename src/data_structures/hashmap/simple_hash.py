"""
哈希算法

1.  无论是开放寻址还是链式地址，它们只能保证哈希表可以在发生冲突时正常工作，而无法减少哈希冲突的发生。如果哈希冲突过于频繁，
    哈希表的性能则会急剧劣化。对于链式地址哈希表，理想情况下键值对均匀分布在各个桶中，达到最佳查询效率；最差情况下所有键值
    对都存储到同一个桶中，时间复杂度退化至 O(n)。
2.  哈希函数的计算步骤为先计算哈希值，再对数组长度取模。当哈希表容量 capacity 固定时，哈希算法 hash() 决定了输出值，进
    而决定了键值对在哈希表中的分布情况。


哈希算法应具备以下特点

1.  确定性：对于相同的输入，哈希算法应始终产生相同的输出。这样才能确保哈希表是可靠的。
2.  效率高：计算哈希值的过程应该足够快。计算开销越小，哈希表的实用性越高。
3.  均匀分布：哈希算法应使得键值对均匀分布在哈希表中。分布越均匀，哈希冲突的概率就越低。


哈希算法除了可以用于实现哈希表，还用于密码存储和数据完整性检查等领域。


简单的哈希算法

1.  加法哈希：对输入的每个字符的 ASCII 码进行相加，将得到的总和作为哈希值。
2.  乘法哈希：利用乘法的不相关性，每轮乘以一个常数，将各个字符的 ASCII 码累积到哈希值中。
3.  异或哈希：将输入数据的每个元素通过异或操作累积到一个哈希值中。
4.  旋转哈希：将每个字符的 ASCII 码累积到一个哈希值中，每次累积之前都会对哈希值进行旋转操作。
每种哈希算法的最后一步都是对大质数 1000000007 取模，以确保哈希值在合适的范围内。「使用大质数
作为模数，可以最大化地保证哈希值的均匀分布。」因为质数不与其他数字存在公约数，可以减少因取模操
作而产生的周期性模式，从而避免哈希冲突。
值得说明的是，如果能够保证 key 是随机均匀分布的，那么选择质数或者合数作为模数都可以，它们都能
输出均匀分布的哈希值。而当 key 的分布存在某种周期性时，对合数取模更容易出现聚集现象。


常见的哈希算法

在实际中，我们通常会用一些标准哈希算法，例如 MD5、SHA-1、SHA-2、SHA-3 等。它们可以将任意长
度的输入数据映射到恒定长度的哈希值。


数据结构的哈希值

哈希表的 key 可以是整数、小数或字符串等数据类型。编程语言通常会为这些数据类型提供内置的哈希算
法，用于计算哈希表中的桶索引。以 Python 为例，我们可以调用 hash() 函数来计算各种数据类型的
哈希值。
- 整数和布尔量的哈希值就是其本身。
- 浮点数和字符串的哈希值计算较为复杂，有兴趣的读者请自行学习。
- 元组的哈希值是对其中每一个元素进行哈希，然后将这些哈希值组合起来，得到单一的哈希值。
- 对象的哈希值基于其内存地址生成。通过重写对象的哈希方法，可实现基于内容生成哈希值。


在许多编程语言中，只有不可变对象才可作为哈希表的 key。假如我们将列表（动态数组）作为 key，当列表
的内容发生变化时，它的哈希值也随之改变，我们就无法在哈希表中查询到原先的 value 了。
虽然自定义对象（比如链表节点）的成员变量是可变的，但它是可哈希的。这是因为对象的哈希值通常是基于内
存地址生成的，即使对象的内容发生了变化，但它的内存地址不变，哈希值仍然是不变的。
细心的你可能发现在不同控制台中运行程序时，输出的哈希值是不同的。这是因为 Python 解释器在每次启动
时，都会为字符串哈希函数加入一个随机的盐（Salt）值。这种做法可以有效防止 HashDoS 攻击，提升哈希
算法的安全性。


Q & A：
哈希表的时间复杂度在什么情况下是 O(n)？
当哈希冲突比较严重时，哈希表的时间复杂度会退化至 O(n)。当哈希函数设计得比较好、容量设置比较合理、
冲突比较平均时，时间复杂度是 O(1)。我们使用编程语言内置的哈希表时，通常认为时间复杂度是 O(1)。

哈希表底层实现是数组、链表、二叉树，但为什么效率可以比它们更高呢？
首先，哈希表的时间效率变高，但空间效率变低了。哈希表有相当一部分内存未使用。
其次，只是在特定使用场景下时间效率变高了。如果一个功能能够在相同的时间复杂度下使用数组或链表实现，
那么通常比哈希表更快。这是因为哈希函数计算需要开销，时间复杂度的常数项更大。
最后，哈希表的时间复杂度可能发生劣化。例如在链式地址中，我们采取在链表或红黑树中执行查找操作，仍
然有退化至 O(n) 时间的风险。

多次哈希有不能直接删除元素的缺陷吗？标记为已删除的空间还能再次使用吗？
多次哈希是开放寻址的一种，开放寻址法都有不能直接删除元素的缺陷，需要通过标记删除。标记为已删除的空
间可以再次使用。当将新元素插入哈希表，并且通过哈希函数找到标记为已删除的位置时，该位置可以被新元素
使用。这样做既能保持哈希表的探测序列不变，又能保证哈希表的空间使用率。


"""


def add_hash(key: str) -> int:
    """加法哈希"""
    hash = 0
    modulus = 1000000007
    for c in key:
        hash += ord(c)
    return hash % modulus


def mul_hash(key: str) -> int:
    """乘法哈希"""
    hash = 0
    modulus = 1000000007
    for c in key:
        hash += 31 * hash + ord(c)
    return hash % modulus


def xor_hash(key: str) -> int:
    """异或哈希"""
    hash = 0
    modulus = 1000000007
    for c in key:
        hash ^= ord(c)
    return hash % modulus


def rot_hash(key: str) -> int:
    """旋转哈希"""
    hash = 0
    modulus = 1000000007
    for c in key:
        hash = (hash << 4) ^ (hash >> 28) ^ ord(c)
    return hash % modulus


if __name__ == '__main__':
    num = 3
    hash_num = hash(num)
    # 整数 3 的哈希值为 3

    bol = True
    hash_bol = hash(bol)
    # 布尔量 True 的哈希值为 1

    dec = 3.14159
    hash_dec = hash(dec)
    # 小数 3.14159 的哈希值为 326484311674566659

    str = "Hello 算法"
    hash_str = hash(str)
    # 字符串“Hello 算法”的哈希值为 4617003410720528961

    tup = (12836, "小哈")
    hash_tup = hash(tup)
    # 元组 (12836, '小哈') 的哈希值为 1029005403108185979

    obj = ListNode(0)
    hash_obj = hash(obj)
    # 节点对象 <ListNode object at 0x1058fd810> 的哈希值为 274267521